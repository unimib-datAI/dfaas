# DFaaS: Decentralized Function-as-a-Service for Federated Edge 

This repository holds DFaaS, a novel decentralized FaaS-based architecture
designed to automatically and autonomously balance the traffic load across edge
nodes belonging to federated Edge Computing ecosystems.

DFaaS implementation relies on an overlay peer-to-peer network and a distributed
control algorithm that takes decisions on load redistribution. Although
preliminary, our results confirm the feasibility of the approach, showing that
the system can transparently redistribute the load across edge nodes when they
become overloaded.

Our prototype is based on OpenFaaS and implements the control logic within Go
P2P agents.

This research is conducted by the DatAI (formerly Insid&s) and
[REDS](https://redslab.altervista.org/) laboratories of the University of
Milan-Bicocca.

If you wish to reuse this source code, please consider citing our article
describing the first prototype:

```
@inproceedings{Ciavotta_DFaaS_2021,
    author = {Ciavotta, Michele and Motterlini, Davide and Savi, Marco and Tundo, Alessandro},
    doi    = {10.1109/CloudNet53349.2021.9657141},
    pages  = {1--4},
    series = {2021 IEEE 10th International Conference on Cloud Networking (CloudNet)},
    title  = {{DFaaS: Decentralized Function-as-a-Service for Federated Edge Computing}},
    url    = {https://ieeexplore.ieee.org/document/9657141},
    year   = {2021}
}
```

## Scenario

![Scenario](images/Scenario-crop.png)

The above figure depicts the considered network scenario. A set of
geographically-distributed _FaaS-enabled edge nodes_ (or simply _edge nodes_) is
deployed at the edge of the access network. 

Each of these nodes deploys a _DFaaS platform_ for the execution of _serverless
functions_, and is connected to a wireless or wired _access point_ (e.g. a base
station, a broadband network gateway, a WiFi access point, etc.).

The edge node can receive functions' execution _requests_, in the form of HTTP
requests, generated by the _users_ served by the access point.

## Architecture

![Architecture](images/Arch-crop.png)

## How to run DFaaS

**DFaaS is currently in a prototypal stage.** It uses
[HAProxy](https://www.haproxy.org/) for the proxy component and
[OpenFaaS](https://www.openfaas.com/) as the FaaS platform. The only supported
deployment method is on Kubernetes.

You can install and deploy the DFaaS prototype on a single node using Ansible.
This can be done either on the machine running Ansible or on a remote machine.
See the dedicated section.

Or you can do a manual deployment: follow what the given Ansible playbook does
and execute each required command step-by-step.

Regardless of which of the options you choose, the deployment of the DFaaS
prototype has been tested with [Ubuntu 24.04.2
LTS](https://releases.ubuntu.com/noble/).

We suggest to spin up a virtual machine from scratch with Ubuntu, with a user
with a password and sudo enabled.

### Automated deployment with Ansible

Install Ansible on the control node following the [official
documentation](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)
(use the Ansible PPA). Then use the provided playbook
[`setup_playbook.yaml`](setup_playbook.yaml) to deploy a DFaaS node on a
specific managed node specified in an inventory file. Note that you can specify
multiple managed nodes.

An example of `inventory.yaml` file is

```yaml
all:
  hosts:
    <node-name>:
      ansible_host: <ip_address>
      ansible_user: <user>
      ansible_password: <password>
      ansible_become: true
```

We assume that the managed node has a user with root privileges and can connect
via SSH with a password. This is for testing purposes only!

To test the inventory, you can try the [example
playbook](https://docs.ansible.com/ansible/latest/getting_started/get_started_playbook.html)
on the official Ansible documentation.

**Important:** on the control node you need to have the DFaaS Git repository and
to build the DFaaS Agent. This can be done with the following:

```console
$ git clone https://github.com/unimib-datAI/dfaas.git
$ sudo apt install golang-go
$ go build -C dfaas/dfaasagent
```

Then you can run the playbook with ansible-playbook (make sure to be on the
DFaaS directory!):

```console
$ ansible-playbook -i inventory.yaml setup_playbook.yaml
```

This deploys a basic, fully functional DFaaS node using the Node Margin
Strategy. See [here](docs/agent-strategies.md) for a list of available
strategies for the agents.

You can make automatic calls to the node with the **operator**. More information
about it in the [dedicated directory](operator).

If you have four different VMs it's recommended to deploy the entire system
exploiting the playbook and configuration files in
[`test_environment`](test_environment). This is still a work in progress.

### Deploy functions

Use the [`k8s/scripts/deploy-functions.sh`](k8s/scripts/deploy-functions.sh)
script to automatically deploy the default function to the local DFaaS instance.
If you used the Ansible playbook or the custom init script, this step is not
required.

### Invoke a function

Each node exposes HAProxy with port `30080` on the node's IP address. Only
`http` protocol is supported. You can use any program to make a call, as
example:

```console
$ curl -i http://127.0.0.1:30080/function/figlet -d 'Hello DFaaS world!'
```

### Execute workload to a node using [vegeta](https://github.com/tsenart/vegeta)

> [!WARNING]  
> Outdated information. We are rewriting this section!

We provide an example that use [vegeta](https://github.com/tsenart/vegeta) HTTP load testing tool to run workload on a node
and demonstrate the load distribution over the federation.

You can install vegeta by executing the following commands:
```shell
wget https://github.com/tsenart/vegeta/releases/download/v12.8.4/vegeta_12.8.4_linux_amd64.tar.gz
tar -xf vegeta_12.8.4_linux_amd64.tar.gz && rm vegeta_12.8.4_linux_amd64.tar.gz
sudo mv vegeta /usr/local/bin/
```

This example uses the [vegeta json format](https://github.com/tsenart/vegeta#json-format) and requires [jq](https://stedolan.github.io/jq/).

In a nutshell:
- it runs a vegeta attack (duration: `5 minutes`, rate: `50 req/s`) to the `figlet` function on the first node
- it saves the results and produces report ever 200ms

```shell
# Create the vegeta results directory
mkdir -p vegeta-results
export VEGFOLDER="vegeta-results/$(date +%Y-%m-%d-%H%M%S)"
mkdir -p $VEGFOLDER

jq -ncM '{method: "GET", url: "http://localhost:8081/function/figlet", body: "Hello DFaaS world!" | @base64, header: {"Content-Type": ["text/plain"]}}' | \
  vegeta attack -duration=5m -rate=50 -format=json | \
  tee $VEGFOLDER/results.bin | \
  vegeta report -every=200ms
```

You can also start multiple parallel Vegeta attacks exploiting [operator](operator) functionalities.

#### Create plots from vegeta results

You can produce some plots from vegeta results by exploiting the `vegeta plot` command or our [plot-results.py](operator/docker/files/plot-results.py) script, which is automatically executed after tests execution with the [operator](operator).
To use our script, you need to install the required Python packages listed in [plot-requirements.txt](operator/docker/files/plot-requirements.txt).

```shell
# Encode results as JSON
cat $VEGFOLDER/results.bin | vegeta encode > $VEGFOLDER/results.json

# Create plot with vegeta
cat $VEGFOLDER/results.bin | vegeta plot > $VEGFOLDER/plot.html

# 1st arg: path  results.json
# 2nd arg: path output folder
# 3rd arg: rate req/s used for the attack (if merged is True specify rate=0)
# 4th arg: boolean merged (is the input file merged from multiple attacks?)
./operator/docker/files/plot-results.py $VEGFOLDER/results.json $VEGFOLDER/plots 50 False
```

### Forwarding traffic as a malicious node

You can impersonate a malicious node that is not part of the federation by
adding the header `Dfaas-Node-Id` with a value that is not a valid peer id of
the network (e.g., `Dfaas-Node-Id: malicious-id`). All of its requests will be
rejected.

### Troubleshooting

See and follow the logs of the DFaaS Agent on the local instance:

```console
$ POD=$(sudo kubectl get pods -l app=dfaas-agent -o jsonpath="{.items[0].metadata.name}")
$ sudo kubectl logs --follow $POD
```

## Emulator

For a complex setup running several emulated edge nodes with different
topologies see [emulator directory](emulator). We provide instructions and
examples to execute DFaaS nodes via [Containernet
emulator](https://containernet.github.io/).

## Simulator

We also provide a simulator to test and compare different load balancing
techniques. The simulation code is available into the [simulation
directory](simulation). Data gathered by the DFaaS system used for simulation
are available [here](simulation/data).

For more information read associated [README](simulation/README.md) file.

## License

Copyright Â© 2021-2025 The DFaaS Authors.

The source code in this repository is licensed under the GNU Affero General
Public License (AGPL), version 2.0 or later. See the [LICENSE](LICENSE) file for
more information.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.

The complete list of The DFaaS Authors can be fond in the [AUTHORS](AUTHORS)
file or in the [contributors
page](https://github.com/unimib-datAI/dfaas/graphs/contributors) on the DFaaS
GitHub repository.
